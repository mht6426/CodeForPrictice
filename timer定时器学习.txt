timer定时器概念：
	以 list_head 为基础，对定时器进行触发及处理操作

tvec_base_t 结构体：

	(1)首先定义一个 细粒度 环形链表，环形链表节点个数为 TVR_SIZE(1 << 8) 个，节点
	类型都为 list_head 
		
		注：因该结构为 内核层 定义实现，但在实际使用中搬移到了 应用层 中，故原定时
		器的终端时钟触发时间为 毫秒级别 ，但实际应用在应用层时 秒级别 已经足够使用
	
	(2)定义多个 粗粒度 环形链表，链表节点个数为 TVN_SIZE(1 << 6) 个，节点类型都为
	list_head 

		注：粗细粒度比以 TVR_SIZE(1 << 8) 大小成倍上涨
	(3)timer_jiffies标志位 -> 可理解为当前程序定时器开始时的起始时间(滴答时钟)
	，在代码中可以alarm信号实现定时功能

timer_list 结构体：
	(1) 嵌入一个 list_head 结构体，实现添加及删除查找节点等功能
	(2) 定时器超时时间
	(3) 超时时间一到，就会执行回调函数，实现相应功能
	(4) 传入回调函数的参数，以 unsigned long 为类型(指针大小)，目的是可将指针传入
	(5) 绑定至某一环形列表


链表创建：

	timer_init函数 -> 内联函数，初始化循环链表，滴答时钟时间，底层调用 
	INIT_LIST_HEAD 函数 使用前需先、申请 tvec_base_t 结构体再做初始化

	init_timer函数 -> 内联函数，初始化链表指针，将 timer_list 的指针指
	向到 tvec_base_t 结构体，并初始化 timer_list 中的list_head指针

链表添加节点：
	mod_timer函数 -> 内联函数，初始化或修改超时时间，为 add_timer函数升级版(多
	了一个超时时间判断，防止无意义的取还节点的操作)

判断计时器是否挂起：
	timer_pending函数 -> 内联函数 根据 timer_list 结构体内的 list_head 结构体
	判断定时器是否挂起，1为挂起，0为非挂起

链表删除节点：
	del_timer函数 —> 内联函数,根据该节点定时器是否挂起来判断及删除环形链表的某一
	节点

循环链表处理节点：
	run_timers函数 -> 内联函数，可理解为推动秒针分针时针转动的函数，用于维护 
	tvec_base_t 结构体内所定义的环表，内部主要还是维护 tvec_root_t tv1 表，
	通过定时器触发时间与滴答时钟的差值来判断该节点在哪个优先级的环表中或在该
	环表下的哪一位置，对该表下的节点进行触发定时器的操作并摘除节点，max_count 
	参数经测试主要是对同一时间下触发定时器的个数进行限制，代码中直接写了1024，

定时器相关函数：
	struct itimerval 结构体:
		struct timeval it_interval -> 定义几秒或及微秒后开启定时器
		struct timeval it_value -> 定义几秒或及微秒后调用信号处理函数
	setitimer()函数：
		参数：
		ITIMER_REAL：以系统真实的时间来计算，它送出SIGALRM信号。
		ITIMER_VIRTUAL：以该进程在用户态下花费的时间来计算，它送出SIGVTALRM信号。
		ITIMER_PROF：以该进程在用户态下和内核态下所费的时间来计算。它送出SIGPROF信号。

	流程：
		初始化 itimerval 结构体 —> 创建处理函数 -> 调用 setitimer() 函数

简易流程：
	1.申请一个 tvec_base_t 类型的结构体并初始化(创建环形链表，初始化滴答时钟)
	(timer_init)
	2.申请一个 timer_list 类型的结构体(初始化定时器超时时间，回调函数，传入回调函数
		的参数)
	3.绑定上述两个结构体(init_timer)
	4.将该定时器添加进环形链表的某一环表中(mod_timer -> add_timer的升级版，
		对超时时间做一步检查判断，防止无效的修改操作)
	5.滴答时钟开始运行时，循环链表需对已挂起的定时器进行检查及处理操作(run_timers)
		代码中在singal函数的触发函数中调用
	6.定时器超时处理函数执行时，对节点进行删除操作(del_timer)

