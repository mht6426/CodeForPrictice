List_head：内核常用双向循环链表，仅为一种数据结构，使用时常嵌入到其他结构体中。

链表创建：
	
	INIT_LIST_HEAD(name) -> 宏定义，根据双链表特性将双指针指向自己。

链表添加节点：
	
	list_add_head(new,head) -> 内联函数，无返回值，在底层调用 _list_add() 
	函数将 head->next 传入实现添加，类似于单链表 -> 头插 ,最终将节点填入双向
	链表中。

	list_add_tail(new,head) -> 内联函数，无返回值，在底层调用 _list_add()
	函数将 head->prev 传入实现添加，类似于单链表 -> 尾插 ,最终将节点填入双向
	链表中。

链表删除节点：

	list_del(list_node) -> 内联函数，无返回值，在底层调用 _list_del()函数
	使用时需注意 该节点必须 真实存在，看源码下无对该节点进行判断，即直接将该节点
	双指针置为最低地址(即无法分配，不可用地址) 

	注：如果该节点被删除，那查询函数是否可正常遍历?

链接遍历节点：
	
	正向遍历：
		list_for_each -> 宏定义，使用for关键字，根据 head->next 遍历下一个节
		点，通过该数据结构遍历到所需节点后，调用  list_entry() -> 宏定义 通过
		container_of() -> 宏定义 实现正向遍历数据查询 

		测试案例:
		在遍历链表的过程中进行删除操作，分别调用 list_for_each()函数 及 list_for_each_safe()
		函数，测试结果为 list_for_each()函数 发生 SIGSEGV 信号，即无效的内存引用

	逆向遍历：
		list_for_each_prev ->宏定义，使用for关键字，根据 head->prev 遍历上一
		个节点，通过该数据结构遍历到所需节点后，调用  list_entry() -> 宏定义  
		通过container_of() -> 宏定义 实现逆向遍历数据查询

查询链表是否为空：
	list_empty() -> 内联函数，为空返回 1 ，不为空返回 0 ，该函数在使用时需注意
	是否有程序在修改该链表，所以引出另一函数：
	list_empty_careful() -> 内联函数，与上述函数相同效果，但可以检测是否有程序
	在修改传入的链表

节点替换函数：
	list_replace_init() -> 内联函数 替换某一节点，并将该节点的双指针做初始化操
	作。

节点移位函数：
	
	List_move() -> 内联函数 用于修改某一结点的位置，该函数底层实现为先 list_del() 再 list_add 

	List_move_tail() -> 内联函数 用于修改某一结点的位置，该函数底层实现为先 list_del() 再 list_add_tail 

question：
	
	1.static inline void prefetch(const void *x) {;} 
	
	因该函数为内核层调用优化处理函数，也就是使用该函数时cpu会通过cache提前缓存该
	函数中的参数方便使用时加快加载速度，在搬移到应用层时，无真实寄存器及物理内存
	地址，即将该函数声明防止编译报错，可忽略。

	相似函数：likely()函数 -> gcc编译可识别
	
	2.container_of()宏定义源码暂未透彻
	
	引入概念： 将该函数通过 0地址 指针强转为所定义的结构体，再根据结构体内成员地址
	获取需要查询的结构体的首地址

	3.#define smp_wmb()
	用于不同架构下的防乱序手段，防止临界资源等数据因数据依赖导致的数据错误问题
	例子： 
		x=1;
		x++;
		y=1;
		y++;
	C语言思想为自上至下执行，但进入cpu后cpu认为 x=1 ,y=1 为相同指令，但若假设x为
	临界资源，则程序会因CPU处理导致错误循行，所以使用该函数防止如上现象发生

	4.再调用API函数时是否需要上锁

	5. *_rcu函数：
	可理解为非上锁函数，具体实现方法大致为将需要修改的数据节点copy一份，并将copy出
	的节点关联至原节点指向的其他节点上，等全部cpu都完成进程切换后，再将被复制的节点
	删除，从而达到不上锁的效果
